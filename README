Asm_Kernel
==========

Assembler 64 bit multi process, multi thread kernel.

Runs on OSX or Linux. Could move to bare metal eventually but it's useful for
now to run hosted while experimenting.

Uses a virtual cpu instruction macro set to avoid use of x64 native
instructions. Couple of things to tidy up here with the vp_div and vp_cpy macros
as they are currently too x64 specific.

Has function level dynamic binding and loading. Individual assembler functions
are loaded and bound on demand as tasks are created and distributed. Currently
functions are loaded from the cpu file system on which the task finds itself,
but these will eventually come from the server object that the task was created
with and functions will be transported across the network as required. Functions
are shared between all tasks that share the same server object, so only a single
copy of a function is loaded regardless of how many tasks use that function.

Allows modeling of various network topologies with point to point links. Each
cpu in the network is modeled as a separate host process, point to point links
use shared memory to simulate cpu to cpu point to point bi directional
connections. There is no global bus based networking on purpose.

Network link routing tables are created on booting a link, and the process is
distributed in nature, each link starts a flood fill that eventually reaches all
the cpus and along the way has marked all the routes from one cpu to another.
All shortest routes are found, messages going off cpu are assigned to a link as
the link becomes free and multiple links can and do route messages over parallel
routes simultaneously.

The -run command line option launches tasks on booting that cpu, such as the
test suit or experimental gui (a work in progress, -run gui/gui).

The -l command line option creates a link, currently up to 100 cpu's are allowed
but that is easy to adjust in the sys/link.nasm file and is due to the very
simple link parameter parsing. The lower numbered cpu always comes first !

The -cpu command line option just labels the cpu with it's ID.

An example network viewed with ps looks like this for a 4x4 mesh network:

13818 ttys001    0:00.55 ./main -cpu 15 -l 11-15 -l 03-15 -l 14-15 -l 12-15
13819 ttys001    0:00.54 ./main -cpu 14 -l 10-14 -l 02-14 -l 13-14 -l 14-15
13820 ttys001    0:00.53 ./main -cpu 13 -l 09-13 -l 01-13 -l 12-13 -l 13-14
13821 ttys001    0:00.54 ./main -cpu 12 -l 08-12 -l 00-12 -l 12-15 -l 12-13
13822 ttys001    0:00.53 ./main -cpu 11 -l 07-11 -l 11-15 -l 10-11 -l 08-11
13823 ttys001    0:00.53 ./main -cpu 10 -l 06-10 -l 10-14 -l 09-10 -l 10-11
13824 ttys001    0:00.53 ./main -cpu 9 -l 05-09 -l 09-13 -l 08-09 -l 09-10
13825 ttys001    0:00.53 ./main -cpu 8 -l 04-08 -l 08-12 -l 08-11 -l 08-09
13826 ttys001    0:00.52 ./main -cpu 7 -l 03-07 -l 07-11 -l 06-07 -l 04-07
13827 ttys001    0:00.55 ./main -cpu 6 -l 02-06 -l 06-10 -l 05-06 -l 06-07
13828 ttys001    0:00.54 ./main -cpu 5 -l 01-05 -l 05-09 -l 04-05 -l 05-06
13829 ttys001    0:00.53 ./main -cpu 4 -l 00-04 -l 04-08 -l 04-07 -l 04-05
13830 ttys001    0:00.54 ./main -cpu 3 -l 03-15 -l 03-07 -l 02-03 -l 00-03
13831 ttys001    0:00.54 ./main -cpu 2 -l 02-14 -l 02-06 -l 01-02 -l 02-03
13832 ttys001    0:00.56 ./main -cpu 1 -l 01-13 -l 01-05 -l 00-01 -l 01-02
13833 ttys001    0:00.54 ./main -cpu 0 -l 00-12 -l 00-04 -l 00-03 -l 00-01 -run tests/test1

Make with:

make

Requires NASM and the SDL2 library to be installed. SDL2 is for the experimental
gui. Please note that there is a bug in NASM 2.11 that may not be fixed yet and
so NASM 2.10 should be used until further notice.

Run with:

./run.sh <num_cpus>
./run_ring.sh <num_cpus>
./run_mesh.sh <num_cpus on a side>

Stop with:

./stop.sh
