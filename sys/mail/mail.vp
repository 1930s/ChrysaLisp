(import 'sys/func.inc)
(import 'sys/kernel/kernel.inc)
(import 'class/string/string.inc)

(def-func 'sys/mail/statics)
	(times ml_statics_size (vp-byte 0))
(def-func-end)

(def-func 'sys/mail/init)
	;inputs
	;r1 = kernel mailbox

	;save kernel mailbox
	(f-entry 'sys_mail 'init '(r1))
	(f-bind 'sys_mail 'statics r6)
	(vp-cpy-ri r1 r6 ml_statics_kernel_mailbox)

	;init off chip list
	(vp-lea-i r6 ml_statics_offchip_list r0)
	(lh-init r0 r1)

	;init in and out postmen tasks
	(f-call 'sys_task 'start `((@ ,(f-path 'sys_mail 'in))) '(r0 (r6 ml_statics_in_mailbox) _))
	(f-call 'sys_task 'start `((@ ,(f-path 'sys_mail 'out))) '(r0 (r6 ml_statics_out_mailbox) _))
	(vp-xor-rr r1 r1)
	(vp-cpy-ri-i r1 r6 ml_statics_parcel_id)
	(vp-ret)

(def-func-end)

(def-func 'sys/mail/init_mailbox)
	;outputs
	;r0 = mailbox address
	;trashes
	;r1-r2

	(f-entry 'sys_mail 'init_mailbox '(r0))
	(ml-init r0 r1 r2)
	(f-exit 'sys_mail 'init_mailbox '(r0))
	(vp-ret)

(def-func-end)

(def-func 'sys/mail/mymail)
	;outputs
	;r0 = mail address
	;r1 = string data
	;trashes
	;r2

	(f-call 'sys_task 'mailbox '() '(r0 r1))
	(f-jmp 'sys_mail 'read '(r0))

(def-func-end)

(def-func 'sys/mail/alloc)
	;inputs
	;r0 = mail size
	;outputs
	;r0 = mail message
	;r1 = string data
	;trashes
	;all

	(ptr 'msg)
	(uint 'total)

	(push-scope)
	(f-entry 'sys_mail 'alloc {total})

	(f-call 'sys_mem 'alloc {msg_header_size + total} {msg, _})
	(assign {0} {msg->msg_parcel_length})
	(assign {msg_header_size + total} {msg->msg_length})
	(assign {&msg->msg_data} {msg->msg_parcel_data})

	(f-exit 'sys_mail 'alloc {msg, msg->msg_parcel_data})
	(pop-scope)
	(return)

(def-func-end)

(def-func 'sys/mail/free)
	;inputs
	;r0 = mail message
	;trashes
	;all

	(ptr 'msg)

	(push-scope)
	(f-entry 'sys_mail 'free {msg})

	(f-call 'sys_mem 'free {msg})

	(pop-scope)
	(return)

(def-func-end)

(def-func 'sys/mail/read)
	;inputs
	;r0 = mailbox address
	;outputs
	;r0 = mail address
	;r1 = string data
	;trashes
	;r2

	(f-entry 'sys_mail 'read '(r0))
	(lh-is-empty r0 0 r2)
	(vpif '(r2 == 0))
		(f-bind 'sys_task 'statics r1)
		(vp-cpy-ir r1 tk_statics_current_tcb r1)
		(vp-cpy-ri r1 r0 mailbox_tcb)
		(f-call 'sys_task 'suspend)
	(endif)
	(lh-get-head r0 0 r0)
	(vp-cpy-rr r0 r1)
	(ln-remove-node r1 r2)
	(f-exit 'sys_mail 'read '(r0 (r0 msg_parcel_data)))
	(vp-ret)

(def-func-end)

(def-func 'sys/mail/try_read)
	;inputs
	;r0 = mailbox address
	;outputs
	;r0 = 0, else mail address
	;r1 = string data
	;trashes
	;r2

	(f-entry 'sys_mail 'try_read '(r0))
	(lh-get-head r0 0 r0)
	(vp-cpy-rr r0 r1)
	(ln-get-succ r0 0 r0)
	(vpif '(r0 != 0))
		(vp-cpy-rr r1 r0)
		(ln-remove-node r1 r2)
		(vp-cpy-ir r0 msg_parcel_data r1)
	(endif)
	(f-exit 'sys_mail 'try_read '(r0 r1))
	(vp-ret)

(def-func-end)

(def-func 'sys/mail/send)
	;inputs
	;r0 = mail message
	;trashes
	;r0-r2

	;on or off chip ?
	(f-entry 'sys_mail 'send '(r2))
	(f-call 'kernel 'id '() '(r0))
	(vp-cpy-ir r2 (add msg_dest id_cpu) r1)
	(vpif '(r0 == r1))
		;on this chip
		(vp-cpy-ir-ui r2 msg_parcel_length r1)
		(vpif '(r1 != 0))
			;mail for postman !
			(f-bind 'sys_mail 'statics r1)
			(vp-cpy-ir r1 ml_statics_in_mailbox r1)
		(else)
			(vp-cpy-ir r2 (add msg_dest id_mbox) r1)
			(vpif '(r1 == 0))
				;mail for kernel !
				(f-bind 'sys_mail 'statics r1)
				(vp-cpy-ir r1 ml_statics_kernel_mailbox r1)
			(endif)
		(endif)
	(vp-label 'post_it)
		(lh-add-at-tail r1 r2 r0)
		(vp-cpy-ir r1 mailbox_tcb r0)
		(vpif '(r0 != 0))
			(vp-xor-rr r2 r2)
			(vp-cpy-ri r2 r1 mailbox_tcb)
			(f-call 'sys_task 'resume '(r0))
		(endif)
	(else)
		;going off chip
		(f-bind 'sys_mail 'statics r1)
		(vp-cpy-ir-ui r2 msg_length r0)
		(vpif '(r0 > msg_size))
			;must use postman task
			(vp-cpy-ir r1 ml_statics_out_mailbox r1)
			(vp-jmp 'post_it)
		(else)
			;queue it on the outgoing packet list
			(vp-lea-i r1 ml_statics_offchip_list r1)
			(lh-add-at-tail r1 r2 r0)
		(endif)
	(endif)
	(vp-ret)

(def-func-end)

(def-func 'sys/mail/select)
	;inputs
	;r0 = mailbox address array
	;r1 = mailbox count
	;outputs
	;r0 = mailbox address
	;trashes
	;r1-r4

	(f-entry 'sys_mail 'select '(r0 r1))
	(vp-cpy-rr r0 r3)
	(vp-shl-cr (log2 ptr_size) r1)
	(vp-lea-d r0 r1 r1)
	(loop-start)
		;check if any have mail
		(vp-cpy-rr r3 r0)
		(loop-start)
			(vp-cpy-ir r0 0 r2)
			(vpif '(r2 != 0))
				(lh-is-empty r2 0 r2)
				(vpif '(r2 != 0))
					;return first mailbox not empty
					(f-exit 'sys_mail 'select '((r0 0)))
					(vp-ret)
				(endif)
			(endif)
			(vp-add-cr ptr_size r0)
		(loop-until '(r0 == r1))

		;fill in all tcb's and suspend
		(f-bind 'sys_task 'statics r4)
		(vp-cpy-ir r4 tk_statics_current_tcb r4)
		(vp-cpy-rr r3 r0)
		(loop-start)
			(vp-cpy-ir r0 0 r2)
			(vpif '(r2 != 0))
				(vp-cpy-ri r4 r2 mailbox_tcb)
			(endif)
			(vp-add-cr ptr_size r0)
		(loop-until '(r0 == r1))

		(f-call 'sys_task 'suspend)

		;clear all tcb's
		(vp-xor-rr r4 r4)
		(vp-cpy-rr r3 r0)
		(loop-start)
			(vp-cpy-ir r0 0 r2)
			(vpif '(r2 != 0))
				(vp-cpy-ri r4 r2 mailbox_tcb)
			(endif)
			(vp-add-cr ptr_size r0)
		(loop-until '(r0 == r1))
	(loop-end)

(def-func-end)

(def-func 'sys/mail/in)
	;parcel fragments arriving on chip task

	(ptr 'msg 'data 'frag 'fdata 'mail_statics)
	(uint 'len)

	(push-scope)
	(f-entry 'sys_mail 'in {})

	(assign (cat {@} (f-path 'sys_mail 'statics)) {mail_statics})

	(loop-start)
		;read parcel fragment
		(f-call 'sys_mail 'mymail {} {frag, fdata})

		;look up parcel in mailbox
		(vp-def next node src id psrc pid)
		(assign {frag->msg_dest.id_mbox, frag->msg_parcel_src, frag->msg_parcel_id}
			(list next src id))
		(loop-list-forward next mailbox_parcel_list node next)
			(vp-cpy-ir node msg_parcel_src psrc)
			(continueif `(,src != ,psrc))
			(vp-cpy-ir-ui node msg_parcel_id pid)
		(loop-until `(,id == ,pid))
		(assign (list node) {msg})
		(vpif `(,next == 0))
			;new parcel
			(f-call 'sys_mail 'alloc {frag->msg_parcel_length - msg_data} {msg, data})
			(assign {frag->msg_parcel_length - msg_data} {msg->msg_parcel_length})
			(assign {frag->msg_dest.id_mbox} {msg->msg_dest.id_mbox})
			(assign {frag->msg_dest.id_cpu} {msg->msg_dest.id_cpu})
			(assign {frag->msg_parcel_src} {msg->msg_parcel_src})
			(assign {frag->msg_parcel_id} {msg->msg_parcel_id})
			(assign {msg_data} {msg->msg_parcel_offset})
			(assign {&frag->msg_dest.id_mbox->mailbox_parcel_list, msg} '(r0 r1))
			(lh-add-at-tail r0 r1 r2)
		(endif)

		;copy fragment data
		(assign {frag->msg_length - msg_data} {len})
		(assign {msg->msg_parcel_length - len} {msg->msg_parcel_length})
		(f-call 'sys_mem 'copy {fdata, msg + msg->msg_parcel_offset, len})
		(assign {msg->msg_parcel_offset + len} {msg->msg_parcel_offset})

		;got all needed ?
		(vpifnot {msg->msg_parcel_length})
			;yes, remove parcel and post it
			(assign {msg} '(r0))
			(ln-remove-node r0 r1)
			(f-call 'sys_mail 'send {msg})
		(endif)

		;free fragment
		(f-call 'sys_mem 'free {frag})
	(loop-end)

	(f-exit 'sys_mail 'in {})
	(pop-scope)
	(return)

(def-func-end)

(def-func 'sys/mail/out)
	;parcels going off chip task

	(ptr 'msg 'data 'frag 'fdata 'mail_statics)
	(uint 'id 'offset 'ammount 'len)

	(push-scope)
	(f-entry 'sys_mail 'out {})

	(f-call 'kernel 'id {} {id})
	(assign (cat {@} (f-path 'sys_mail 'statics)) {mail_statics})

	(loop-start)
		;read parcel
		(f-call 'sys_mail 'mymail {} {msg, data})

		;create next parcel id
		(assign {mail_statics->ml_statics_parcel_id + 1} {mail_statics->ml_statics_parcel_id})

		;for each fragment
		(assign {msg_data} {offset})
		(assign {msg->msg_length - msg_data} {ammount})
		(loop-start)
			;create fragment
			(f-call 'sys_mail 'alloc {mail_data_size} {frag, fdata})

			;fill in fragment header
			(assign {msg->msg_dest.id_mbox} {frag->msg_dest.id_mbox})
			(assign {msg->msg_dest.id_cpu} {frag->msg_dest.id_cpu})
			(assign {offset} {frag->msg_parcel_offset})
			(assign {msg->msg_length} {frag->msg_parcel_length})
			(assign {id} {frag->msg_parcel_src})
			(assign {mail_statics->ml_statics_parcel_id} {frag->msg_parcel_id})

			;copy fragment data
			(assign {ammount} {len})
			(vpif {len > mail_data_size})
				(assign {mail_data_size} {len})
			(endif)
			(f-call 'sys_mem 'copy {msg + offset, frag + offset, len})
			(assign {ammount - len} {ammount})

			;queue it on the outgoing packet list
			(assign {&mail_statics->ml_statics_offchip_list, frag} '(r0 r1))
			(lh-add-at-tail r0 r1 r2)

			;let links get at some packets
			(f-call 'sys_task 'yield)
		(loop-untilnot {ammount})

		;free parcel
		(f-call 'sys_mem 'free {msg})
	(loop-end)

	(f-exit 'sys_mail 'out {})
	(pop-scope)
	(return)

(def-func-end)
