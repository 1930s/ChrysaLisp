(import 'sys/func.inc)
(import 'sys/link/link.inc)
(import 'sys/kernel/kernel.inc)
(import 'class/array/array.inc)

(def-func 'sys/link/statics)
	(times lk_statics_size (vp-byte 0))
(def-func-end)

(def-func 'sys/link/init)
	;create link array
	(f-call 'array 'create '() '(r0))
	(f-bind 'sys_link 'statics r1)
	(vp-cpy-ri r0 r1 lk_statics_links_array)
	(vp-ret)

(def-func-end)

(def-func 'sys/link/link)
	;started by kernel for each link

	(struct 'lk_node 'lk_node)
	(ptr 'link_statics 'task_statics 'mail_statics 'params)
	(ptr 'msg 'data 'rx 'tx 'mem 'rx_msg 'tx_msg 'out_msg)
	(pubyte 'pdata)
	(ulong 'handle)
	(uint 'lo_id 'hi_id 'id)

	(push-scope)
	(f-entry 'sys_link 'link {})

	;decrement task count
	;don't count links in load balancing
	(assign (cat {@} (f-path 'sys_mail 'statics)) {mail_statics})
	(assign (cat {@} (f-path 'sys_task 'statics)) {task_statics})
	(assign (cat {@} (f-path 'sys_link 'statics)) {link_statics})
	(assign {link_statics->tk_statics_task_count - 1} {link_statics->tk_statics_task_count})

	;allocate link node on stack and add to link array
	(assign {0, 0} {lk_node.lk_table_array, lk_node.lk_table_array_size})
	(f-call 'array 'push_back {link_statics->lk_statics_links_array, &lk_node})

	;read params msg from kernel
	(f-call 'sys_mail 'mymail {} {params, pdata})

	;init link node cpu id and task count
	(assign {((pdata[5] - 0x30) * 100) + ((pdata[6] - 0x30) * 10) + (pdata[7] - 0x30)} {lo_id})
	(assign {((pdata[9] - 0x30) * 100) + ((pdata[10] - 0x30) * 10) + (pdata[11] - 0x30)} {hi_id})
	(f-call 'kernel 'id {} {id})
	(vpif {id == lo_id})
		(assign {hi_id} {lk_node.lk_node_cpu_id})
		(assign {lk_buffer_chan_1} {tx})
		(assign {lk_buffer_chan_2} {rx})
	(else)
		(assign {lo_id} {lk_node.lk_node_cpu_id})
		(assign {lk_buffer_chan_2} {tx})
		(assign {lk_buffer_chan_1} {rx})
	(endif)
	(assign {0} {lk_node.lk_node_task_count})

	;send link routing message to neighbor kernel
	(f-call 'sys_mail 'alloc {kn_msg_link_route_size} {msg, data})
	(assign {0} {msg->msg_dest.id_mbox})
	(assign {lk_node.lk_node_cpu_id} {msg->msg_dest.id_cpu})
	(assign {kn_call_route} {data->kn_msg_function})
	(assign {0} {data->kn_msg_user})
	(assign {0} {data->kn_msg_reply_id.id_mbox})
	(assign {0} {data->kn_msg_reply_id.id_cpu})
	(assign {id} {data->kn_msg_link_route_origin})
	(assign {id} {data->kn_msg_link_route_via})
	(assign {1} {data->kn_msg_link_route_hops})
	(f-call 'sys_mail 'send {msg})

	;open shared memory file
	(f-call 'pii 'open {pdata, o_creat | o_rdwr, s_irusr | s_iwusr} {handle})

	;set size of region
	(f-call 'pii 'ftruncate {handle, lk_buffer_size})

	;map shared object
	(f-call 'pii 'mmap {0, lk_buffer_size, prot_read | prot_write, map_shared, handle, 0} {mem})

	;tx channel, rx channel
	;tx msg, rx msg
	(assign {mem + tx, mem + rx} {tx, rx})
	(assign {&tx->lk_chan_msg0, &rx->lk_chan_msg0} {tx_msg, rx_msg})

	;clear tx channel
	(f-call 'sys_mem 'clear {tx, lk_chan_size})

	;read and write messages through the shared buffer
	(assign {0} {out_msg})
	(loop-start)
		;exchange task counts
		(assign {task_statics->tk_statics_task_count} {tx->lk_chan_task_count})
		(assign {rx->lk_chan_task_count} {lk_node.lk_node_task_count})

		;check if we need to grab a new message
		(vpifnot {out_msg})
		(vp-label 'more_output)
			;no outgoing message so see if any off chip mail for me
			(vp-def next node id mid table)
			(assign {mail_statics, lk_node.lk_node_cpu_id, lk_node.lk_node_table.lk_table_array}
				(list next id table))
			(loop-list-forward next ml_statics_offchip_list node next)
				(vp-cpy-ir node (add msg_dest id_cpu) mid)
				(breakif `(,id == ,mid))
				(continueif `(,table == 0))
				(vp-mul-cr lk_route_size mid)
				(vp-add-rr table mid)
				(vp-cpy-ir-ui mid lk_route_hops mid)
			(loop-until `(,mid != 0))
			(vpif `(,next != 0))
				(assign (list node) {out_msg})
				(ln-remove-node node next)
			(endif)
		(endif)

		;if we have a message to send then see if we can send it
		(vpif {out_msg})
			(vpif {tx_msg->lk_msg_status == lk_chan_status_ready})
				;copy message data
				(f-call 'sys_mem 'copy {out_msg + ln_node_size, &tx_msg->lk_msg_stamp, msg_stamp_size - ln_node_size})
				(f-call 'sys_mem 'copy {out_msg->msg_parcel_data, &tx_msg->lk_msg_data, (out_msg->msg_length + long_size - 1) & - long_size})

				;busy status
				(assign {lk_chan_status_busy} {tx_msg->lk_msg_status})

				;free message
				(f-call 'sys_mail 'free {out_msg})
				(assign {0} {out_msg})

				;move on to next msg chan
				(assign {&tx_msg->lk_msg_size} {tx_msg})
				(vpif {tx_msg == &tx->lk_chan_size})
					(assign {&tx->lk_chan_msg0} {tx_msg})
				(endif)
				(vp-jmp 'more_output)
			(endif)
		(endif)

		;check for received message
		(vpif {rx_msg->lk_msg_status == lk_chan_status_busy})
			;allocate msg, copy over data
			(f-call 'sys_mail 'alloc {uint(rx_msg->lk_msg_stamp)} {msg, data})
			(f-call 'sys_mem 'copy {&rx_msg->lk_msg_stamp, msg + ln_node_size, msg_stamp_size - ln_node_size})
			(f-call 'sys_mem 'copy {&rx_msg->lk_msg_data, data, (uint(rx_msg->lk_msg_stamp) + long_size - 1) & - long_size})

			;clear status
			(assign {lk_chan_status_ready} {rx_msg->lk_msg_status})

			;send onwards
			(f-call 'sys_mail 'send {msg})

			;move on to next msg chan
			(assign {&rx_msg->lk_msg_size} {rx_msg})
			(vpif {rx_msg == &rx->lk_chan_size})
				(assign {&rx->lk_chan_msg0} {rx_msg})
			(endif)
		(endif)

		;let other links run
		(f-call 'sys_task 'yield)

		;are we in a quiet period
		(continueif {rx_msg->lk_msg_status == lk_chan_status_busy})
		(continueif {out_msg && (tx_msg->lk_msg_status == lk_chan_status_ready)})

		;small sleep if so
		(f-call 'sys_task 'sleep {1000})

		;exit if signaled by kernel
	(loop-until {lk_node.lk_node_cpu_id == 0xffffffff})

	;unmap object
	(f-call 'pii 'munmap {mem, lk_buffer_size})

	;close it
	(f-call 'pii 'close {handle})

	;unlink shared object
	(f-call 'pii 'unlink {pdata})

	;free params msg
	(f-call 'sys_mail 'free {params})

	;remove from links array and deallocate link node on stack
	(f-call 'sys_mem 'free {lk_node.lk_node_table})

	;restore task count
	(assign {link_statics->tk_statics_task_count + 1} {link_statics->tk_statics_task_count})

	(f-exit 'sys_link 'link {})
	(pop-scope)
	(return)

(def-func-end)
