(import 'sys/func.inc)
(import 'class/points/points.inc)
(import 'class/vector/vector.inc)
(import 'sys/math/math.inc)

(gen-new 'points)
(gen-create 'points)
(gen-class 'points)

(def-func 'class/points/rem_co_polyline)
	;inputs
	;r0 = points object
	;r1 = dest points object, can be same
	;r2 = 16.16 tolerance
	;outputs
	;r0 = points object
	;trashes
	;all but r0, r4

	(ptr 'this 'that)
	(pptr 'iter_begin 'iter_end 'iter_that)
	(int 'eps)

	(push-scope)
	(f-entry 'points 'rem_co_polyline {this, that, eps})

	(f-call 'points 'get_begin {this} {_, iter_begin})
	(f-call 'points 'get_end {this} {_, iter_end})
	(f-call 'points 'get_begin {that} {_, iter_that})

	(vec-set 0)
	(vec-load 2 {iter_end, iter_begin})
	(vec-dup 2)
	(vec-dif 2)
	(vpif `(,(elem 0 (vec-pop 1)) > long_size))
		(vec-load 2 {eps, iter_that})
		(vec-def (vec-top 4) e i x j)
		(loop-start 'outer_loop)
			(vpif `(,i != ,j))
				(vec-load-long 1 i)
				(vec-store-long 1 j)
			(endif)
			(loop-start)
				(vp-add-cr long_size i)
				(breakif `(,i == ,e) outer_loop)
				(vec-load-int 2 j)
				(vec-load-int 2 i)
				(vec-manhattan 2)
			(loop-until `(,(elem 0 (vec-pop 1)) >= ,x))
			(vp-add-cr long_size j)
		(loop-end)
		(vec-store 1 {iter_end})
		(f-call 'points 'set_length {that, (iter_end - iter_that >> 3) + 1})
	(endif)

	(f-exit 'points 'rem_co_polyline {this})
	(pop-scope)
	(return)

(def-func-end)

(def-func 'class/points/rem_co_polygon)
	;inputs
	;r0 = points object
	;r1 = dest points object, can be same
	;r2 = 16.16 tolerance
	;outputs
	;r0 = points object
	;trashes
	;all but r0, r4

	(ptr 'this 'that)
	(pptr 'iter_begin 'iter_end)
	(int 'eps)

	(push-scope)
	(f-entry 'points 'rem_co_polygon {this, that, eps})

	(f-call 'points 'rem_co_polyline {this, that, eps})
	(f-call 'points 'get_begin {that} {_, iter_begin})
	(f-call 'points 'get_end {that} {_, iter_end})

	(vec-set 0)
	(vec-load 2 {iter_end, iter_begin})
	(vec-dup 2)
	(vec-dif 2)
	(vpif `(,(elem 0 (vec-pop 1)) > long_size))
		(vec-load 1 {eps})
		(vec-def (vec-top 3) e i x)
		(vec-load-int 2 i)
		(vec-load-int 2 e (neg long_size))
		(vec-manhattan 2)
		(vpif `(,(elem 0 (vec-pop 1)) < ,x))
			(d-call 'points 'pop_back {that})
		(endif)
	(endif)

	(f-exit 'points 'rem_co_polygon {this})
	(pop-scope)
	(return)

(def-func-end)

(def-func 'class/points/gen_clerp)
	;inputs
	;r0 = points object
	;r1 = stack array
	;r2 = 16.16/16.16 c.xy
	;r3 = 16.16/16.16 v1.xy
	;r5 = 16.16/16.16 v2.xy
	;r6 = 16.16 radius
	;r7 = 16.16 tolerance
	;outputs
	;r0 = points object
	;trashes
	;all but r0, r4

	(ptr 'this 'stack)
	(pulong 'iter_end)
	(union
		'(ulong 'c 'v1 'v2 'bv)
		'(int 'cx 'cy 'v1x 'v1y 'v2x 'v2y 'bvx 'bvy))
	(int 'radius 'eps)
	(uint 'start 'length)

	(push-scope)
	(f-entry 'points 'gen_clerp {this, stack, c, v1, v2, radius, eps})

	(vpif {radius >= 0.5})
		;output first point
		(vec-set 0)
		(vec-load 2 {cx, cy} {v1x, v1y})
		(vec-add 2)
		(vec-store 2 {bvx, bvy})
		(f-call 'points 'push_back {this, bv})

		(d-call 'array 'get_length {stack} {_, start})
		(loop-start)
			;calculate the mid-point
			(vec-load 2 {v1x, v1y} {v2x, v2y})
			(vec-add 2)
			(vec-norm 2)
			(vec-load 1 {radius})
			(vec-scale 2)
			(vec-store 2 {bvx, bvy})

			;flatness test
			(vec-load 1 {v1x} {v2x})
			(vec-add 1)
			(vec-load 1 {bvx})
			(vec-dup 1)
			(vec-dif 3)
			(vec-load 1 {v1y} {v2y})
			(vec-add 1)
			(vec-load 1 {bvy})
			(vec-dup 1)
			(vec-dif 3)
			(vec-abs 2)
			(vec-sum 2)

			(vec-load 1 {eps})
			(vec-def (vec-pop 2) d e)
			(vpif `(,d <= ,e))
				;output point
				(vec-load 2 {cx, cy} {bvx, bvy})
				(vec-add 2)
				(vec-store 2 {bvx, bvy})
				(f-call 'points 'push_back {this, bv})
			(else)
				;continue subdivision
				(d-call 'array 'get_length {stack} {_, length})
				(f-call 'array 'set_capacity {stack, length + 4})
				(f-call 'array 'get_end {stack} {_, iter_end})
				(f-call 'array 'set_length {stack, length + 4})
				(vec-load 5 {bv, v2, v1, bv, iter_end})
				(vec-def (vec-pop 1) p)
				(vec-store-long 4 p)
			(endif)

			(d-call 'array 'get_length {stack} {_, length})
			(breakif {length == start})
			(f-call 'array 'set_length {stack, length - 2})
			(f-call 'array 'get_end {stack} {_, iter_end})
			(vec-load 1 {iter_end})
			(vec-def (vec-top 1) p)
			(vec-load-long 2 p)
			(vec-store 2 {v1, v2})
			(vec-pop 1)
		(loop-end)

		;output last point
		(vec-load 2 {cx, cy} {v2x, v2y})
		(vec-add 2)
		(vec-store 2 {bvx, bvy})
		(f-call 'points 'push_back {this, bv})
	(endif)

	(f-exit 'points 'gen_clerp {this})
	(pop-scope)
	(return)

(def-func-end)

(def-func 'class/points/gen_arc)
	;inputs
	;r0 = points object
	;r1 = stack array
	;r2 = 16.16/16.16 c.xy
	;r3 = 16.16 a1
	;r5 = 16.16 a2
	;r6 = 16.16 radius
	;r7 = 16.16 tolerance
	;outputs
	;r0 = points object
	;trashes
	;all but r0, r4

	(ptr 'this 'stack)
	(union
		'(ulong 'c 'v1 'v2)
		'(int 'cx 'cy 'v1x 'v1y 'v2x 'v2y))
	(union
		'(int 'ca1 'ca2 'sa1 'sa2)
		'(int 'a1 'a2 'ah))
	(int 'radius 'eps)

	(push-scope)
	(f-entry 'points 'gen_arc {this, stack, c, a1, a2, radius, eps})

	(vpif {radius >= 0.5})
		(f-call 'math 'fmod {a1, fp_2pi} {a1})
		(f-call 'math 'fmod {a2, fp_2pi} {a2})

		(vpif {a2 <= 3.0})
			(assign {a1 + a2} {a2})
			(f-call 'math 'fsin {a1} {sa1})
			(f-call 'math 'fcos {a1} {ca1})
			(f-call 'math 'fsin {a2} {sa2})
			(f-call 'math 'fcos {a2} {ca2})
			(vec-load 5 {sa1, ca1, sa2, ca2, radius})
			(vec-scale 4)
			(vec-store 2 {v2x, v2y} {v1x, v1y})
			(f-call 'points 'gen_clerp {this, stack, c, v1, v2, radius, eps})
		(else)
			(assign {a2 >>> 1} {ah})
			(assign {a1 + ah} {a2})
			(f-call 'points 'gen_arc {this, stack, c, a1, ah, radius, eps})
			(f-call 'points 'gen_arc {this, stack, c, a2, ah, radius, eps})
		(endif)
	(endif)

	(f-exit 'points 'gen_arc {this})
	(pop-scope)
	(return)

(def-func-end)

(def-func 'class/points/gen_bezier)
	;inputs
	;r0 = points object
	;r1 = stack array
	;r2 = 16.16/16.16 p1.xy
	;r3 = 16.16/16.16 p2.xy
	;r5 = 16.16/16.16 p3.xy
	;r6 = 16.16/16.16 p4.xy
	;r7 = 16.16 tolerance
	;outputs
	;r0 = points object
	;trashes
	;all but r0, r4

	(ptr 'this 'stack)
	(pulong 'iter_end)
	(union
		'(ulong 'p1 'p2 'p3 'p4)
		'(int 'p1x 'p1y 'p2x 'p2y 'p3x 'p3y 'p4x 'p4y))
	(union
		'(ulong 'p12 'p23 'p34 'p123 'p234 'p1234)
		'(int 'p12x 'p12y 'p23x 'p23y 'p34x 'p34y 'p123x 'p123y 'p234x 'p234y 'p1234x 'p1234y))
	(uint 'start 'length)
	(int 'eps)

	(push-scope)
	(f-entry 'points 'gen_bezier {this, stack, p1, p2, p3, p4, eps})

	;output first point
	(vec-set 0)
	(f-call 'points 'push_back {this, p1})

	(d-call 'array 'get_length {stack} {_, start})
	(loop-start)
		;calculate the mid-points
		(vec-load 6 {p1x, p1y, p2x, p2y, p3x, p3y})
		(vec-load 6 {p2x, p2y, p3x, p3y, p4x, p4y})
		(vec-add 6)
		(vec-asr 6 1)
		(vec-store 6 {p12x, p12y, p23x, p23y, p34x, p34y})
		(vec-load 4 {p12x, p12y, p23x, p23y})
		(vec-load 4 {p23x, p23y, p34x, p34y})
		(vec-add 4)
		(vec-asr 4 1)
		(vec-store 4 {p123x, p123y, p234x, p234y})
		(vec-load 2 {p123x, p123y} {p234x, p234y})
		(vec-add 2)
		(vec-asr 2 1)
		(vec-store 2 {p1234x, p1234y})

		;flatness test
		(vec-load 1 {p1x} {p3x})
		(vec-add 1)
		(vec-load 1 {p2x})
		(vec-dup 1)
		(vec-dif 3)
		(vec-load 1 {p1y} {p3y})
		(vec-add 1)
		(vec-load 1 {p2y})
		(vec-dup 1)
		(vec-dif 3)
		(vec-load 1 {p2x} {p4x})
		(vec-add 1)
		(vec-load 1 {p3x})
		(vec-dup 1)
		(vec-dif 3)
		(vec-load 1 {p2y} {p4y})
		(vec-add 1)
		(vec-load 1 {p3y})
		(vec-dup 1)
		(vec-dif 3)
		(vec-abs 4)
		(vec-sum 4)

		(vec-load 1 {eps})
		(vec-def (vec-pop 2) d e)
		(vpif `(,d <= ,e))
			;output point
			(f-call 'points 'push_back {this, p1234})
		(else)
			;continue subdivision
			(d-call 'array 'get_length {stack} {_, length})
			(f-call 'array 'set_capacity {stack, length + 8})
			(f-call 'array 'get_end {stack} {_, iter_end})
			(f-call 'array 'set_length {stack, length + 8})
			(vec-load 9 {p1234, p234, p34, p4, p1, p12, p123, p1234, iter_end})
			(vec-def (vec-pop 1) p)
			(vec-store-long 8 p)
		(endif)

		(d-call 'array 'get_length {stack} {_, length})
		(breakif {length == start})
		(f-call 'array 'set_length {stack, length - 4})
		(f-call 'array 'get_end {stack} {_, iter_end})
		(vec-load 1 {iter_end})
		(vec-def (vec-top 1) p)
		(vec-load-long 4 p)
		(vec-store 4 {p1, p2, p3, p4})
		(vec-pop 1)
	(loop-end)

	;output last point
	(f-call 'points 'push_back {this, p4})

	(f-exit 'points 'gen_bezier {this})
	(pop-scope)
	(return)

(def-func-end)

(def-func 'class/points/gen_polyline_joints)
	;inputs
	;r0 = points object
	;r1 = stack array
	;r2 = in points iter_i
	;r3 = in points iter_j
	;r5 = 16.16/16.16 p1.xy
	;r6 = 16.16/16.16 p2.xy
	;r7 = join style
	;r8 = 16.16 radius
	;r9 = 16.16 tolerance
	;outputs
	;r0 = points object
	;trashes
	;all but r0, r4

	(union
		'(ulong 'p1 'p2 'p0 'p 'l2_v 'l2_pv 'l2_npv 'l2_rv 'l1_v 'l1_pv 'l1_npv 'l1_rv)
		'(int 'p1x 'p1y 'p2x 'p2y 'p0x 'p0y 'px 'py
			'l2_vx 'l2_vy 'l2_pvx 'l2_pvy 'l2_npvx 'l2_npvy 'l2_rvx 'l2_rvy
			'l1_vx 'l1_vy 'l1_pvx 'l1_pvy 'l1_npvx 'l1_npvy 'l1_rvx 'l1_rvy))
	(pulong 'iter_i 'iter_j)
	(ptr 'this 'stack)
	(int 'radius 'eps 'step 'c)
	(byte 'join_style)

	(push-scope)
	(f-entry 'points 'gen_polyline_joints {this, stack, iter_i, iter_j, p1, p2, join_style, radius, eps})

	(vpif {radius >= 0.5 && iter_i != iter_j})
		(vpif {iter_j > iter_i})
			(assign {long_size} {step})
		(else)
			(assign {-long_size} {step})
		(endif)

		(vec-set 0)
		(vec-load 2 {p2x, p2y} {p1x, p1y})
		(vec-sub 2)
		(vec-dup 2)
		(vec-store 2 {l2_vx, l2_vy})
		(vec-perp)
		(vec-dup 2)
		(vec-store 2 {l2_pvx, l2_pvy})
		(vec-norm 2)
		(vec-dup 2)
		(vec-store 2 {l2_npvx, l2_npvy})
		(vec-load 1 {radius})
		(vec-scale 2)
		(vec-store 2 {l2_rvx, l2_rvy})

		(loop-start)
			(vec-load 4 {p2, l2_v, l2_npv, l2_rv})
			(vec-store 4 {p1, l1_v, l1_npv, l1_rv})
			(assign {*iter_i, iter_i + step} {p2, iter_i})
			(vec-load 2 {p2x, p2y} {p1x, p1y})
			(vec-sub 2)
			(vec-dup 2)
			(vec-store 2 {l2_vx, l2_vy})
			(vec-perp)
			(vec-dup 2)
			(vec-store 2 {l2_pvx, l2_pvy})
			(vec-norm 2)
			(vec-dup 2)
			(vec-store 2 {l2_npvx, l2_npvy})
			(vec-load 1 {radius})
			(vec-scale 2)
			(vec-store 2 {l2_rvx, l2_rvy})

			;what kind of join
			(vec-load 2 {l1_npvx, l1_npvy} {l2_npvx, l2_npvy})
			(vec-perp)
			(vec-dot 2)
			(vec-store 1 {c})

			(switch)
			(case {c <= 0 || join_style == join_miter})
				;mitre join
				(vec-load 2 {p1x, p1y} {l1_rvx, l1_rvy})
				(vec-add 2)
				(vec-store 2 {p0x, p0y})
				(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
				(vec-add 2)
				(vec-store 2 {px, py})
				(f-call 'math 'vec_intersect {p0, l1_v, p, l2_v} {p})
				(f-call 'points 'push_back {this, p})
				(break)
			(case {join_style == join_bevel})
				;bevel join
				(vec-load 2 {p1x, p1y} {l1_rvx, l1_rvy})
				(vec-add 2)
				(vec-store 2 {px, py})
				(f-call 'points 'push_back {this, p})
				(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
				(vec-add 2)
				(vec-store 2 {px, py})
				(f-call 'points 'push_back {this, p})
				(break)
			(default)
				;rounded join
				(f-call 'points 'gen_clerp {this, stack, p1, l1_rv, l2_rv, radius, eps})
			(endswitch)
		(loop-until {iter_i == iter_j})
	(endif)

	(f-exit 'points 'gen_polyline_joints {this})
	(pop-scope)
	(return)

(def-func-end)

(def-func 'class/points/stroke_polygons)
	;r0 = vector for output polygons
	;r1 = stack array
	;r2 = vector of input polygons
	;r3 = join style
	;r5 = 16.16 radius
	;r6 = 16.16 tolerance
	;outputs
	;r0 = vector for output polygons
	;trashes
	;all but r0, r4

	(ptr 'this 'in_polygons 'stack 'polygon)
	(pptr 'iter_begin_polygons 'iter_end_polygons)
	(pulong 'iter_begin_polyline 'iter_end_polyline)
	(union
		'(ulong 'p1 'p2)
		'(int 'p1x 'p1y 'p2x 'p2y))
	(int 'radius 'eps)
	(byte 'join_style)

	(push-scope)
	(f-entry 'points 'stroke_polygons {this, stack, in_polygons, join_style, radius, eps})

	(vpif {radius >= 0.5})
		(f-call 'vector 'get_begin {in_polygons} {_, iter_begin_polygons})
		(f-call 'vector 'get_end {in_polygons} {_, iter_end_polygons})
		(loop-while {iter_begin_polygons != iter_end_polygons})
			(f-call 'points 'rem_co_polygon {*iter_begin_polygons, *iter_begin_polygons, 0.5})
			(f-call 'vector 'get_begin {*iter_begin_polygons} {_, iter_begin_polyline})
			(f-call 'vector 'get_end {*iter_begin_polygons} {_, iter_end_polyline})
			(f-call 'points 'create {} {polygon})
			(assign {iter_end_polyline[-long_size * 2], iter_end_polyline[-long_size]} {p1, p2})
			(f-call 'points 'gen_polyline_joints {polygon, stack, iter_begin_polyline, iter_end_polyline,
				p1, p2, join_style, radius, eps})
			(f-call 'vector 'push_back {this, polygon})
			(f-call 'points 'create {} {polygon})
			(assign {iter_begin_polyline[long_size], *iter_begin_polyline} {p1, p2})
			(f-call 'points 'gen_polyline_joints {polygon, stack, iter_end_polyline - long_size, iter_begin_polyline - long_size,
				p1, p2, join_style, radius, eps})
			(f-call 'vector 'push_back {this, polygon})
			(assign {iter_begin_polygons + ptr_size} {iter_begin_polygons})
		(loop-end)
	(endif)

	(f-exit 'points 'stroke_polygons {this})
	(pop-scope)
	(return)

(def-func-end)

(def-func 'class/points/stroke_polylines)
	;inputs
	;r0 = vector for output polygons
	;r1 = stack array
	;r2 = vector of input polylines
	;r3 = join style
	;r5 = cap style1
	;r6 = cap style2
	;r7 = 16.16 radius
	;r8 = 16.16 tolerance
	;outputs
	;r0 = vector for output polygons
	;trashes
	;all but r0, r4

	(union
		'(ulong 'p1 'p2 'p0 'p 'l2_v 'l2_pv 'l2_npv 'l2_rv 'l1_v 'l1_pv 'l1_npv 'l1_rv)
		'(int 'p1x 'p1y 'p2x 'p2y 'p0x 'p0y 'px 'py
			'l2_vx 'l2_vy 'l2_pvx 'l2_pvy 'l2_npvx 'l2_npvy 'l2_rvx 'l2_rvy
			'l1_vx 'l1_vy 'l1_pvx 'l1_pvy 'l1_npvx 'l1_npvy 'l1_rvx 'l1_rvy))
	(pulong 'iter 'iter_begin 'iter_end)
	(pptr 'iter_begin_polylines 'iter_end_polylines)
	(ptr 'this 'stack 'out_points)
	(int 'radius 'eps 'step 'c)
	(byte 'join_style 'cap1_style 'cap2_style)

	(push-scope)
	(f-entry 'points 'stroke_polylines {this, stack, iter_end_polylines, join_style, cap1_style, cap2_style, radius, eps})

	(vpif {radius >= 0.5})
		(vec-set 0)
		(f-call 'vector 'get_begin {iter_end_polylines} {_, iter_begin_polylines})
		(f-call 'vector 'get_end {iter_end_polylines} {_, iter_end_polylines})
		(loop-while {iter_begin_polylines != iter_end_polylines})
			(assign {*iter_begin_polylines} {iter_begin})
			(f-call 'points 'rem_co_polyline {iter_begin, iter_begin, 0.5})
			(f-call 'points 'get_begin {iter_begin} {_, iter})
			(f-call 'points 'get_end {iter_begin} {_, iter_end})
			(f-call 'points 'create {} {out_points})
			(assign {iter - long_size, long_size} {iter_begin, step})
			(loop-start)
				(assign {*iter, iter + step} {p1, iter})
				(assign {*iter, iter + step} {p2, iter})
				(vec-load 2 {p2x, p2y} {p1x, p1y})
				(vec-sub 2)
				(vec-dup 2)
				(vec-store 2 {l2_vx, l2_vy})
				(vec-perp)
				(vec-dup 2)
				(vec-store 2 {l2_pvx, l2_pvy})
				(vec-norm 2)
				(vec-dup 2)
				(vec-store 2 {l2_npvx, l2_npvy})
				(vec-load 1 {radius})
				(vec-scale 2)
				(vec-store 2 {l2_rvx, l2_rvy})

				(vpif {step > 0})
					(assign {cap1_style} {c})
				(else)
					(assign {cap2_style} {c})
				(endif)
				(switch)
				(case {c == cap_butt})
					;butt cap
					(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
					(vec-sub 2)
					(vec-store 2 {px, py})
					(f-call 'points 'push_back {out_points, p})
					(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
					(vec-add 2)
					(vec-store 2 {px, py})
					(f-call 'points 'push_back {out_points, p})
					(break)
				(case {c == cap_square})
					;square cap
					(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
					(vec-perp)
					(vec-add 2)
					(vec-store 2 {p0x, p0y})
					(vec-load 2 {p0x, p0y} {l2_rvx, l2_rvy})
					(vec-sub 2)
					(vec-store 2 {px, py})
					(f-call 'points 'push_back {out_points, p})
					(vec-load 2 {p0x, p0y} {l2_rvx, l2_rvy})
					(vec-add 2)
					(vec-store 2 {px, py})
					(f-call 'points 'push_back {out_points, p})
					(break)
				(case {c == cap_tri})
					;triangle cap
					(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
					(vec-sub 2)
					(vec-store 2 {px, py})
					(f-call 'points 'push_back {out_points, p})
					(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
					(vec-perp)
					(vec-add 2)
					(vec-store 2 {px, py})
					(f-call 'points 'push_back {out_points, p})
					(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
					(vec-add 2)
					(vec-store 2 {px, py})
					(f-call 'points 'push_back {out_points, p})
					(break)
				(case {c == cap_arrow})
					;arrow cap
					(vec-load 3 {l2_rvx, l2_rvy, 2.0})
					(vec-scale 2)
					(vec-store 2 {p0x, p0y})
					(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
					(vec-sub 2)
					(vec-store 2 {px, py})
					(f-call 'points 'push_back {out_points, p})
					(vec-load 2 {p1x, p1y} {p0x, p0y})
					(vec-sub 2)
					(vec-store 2 {px, py})
					(f-call 'points 'push_back {out_points, p})
					(vec-load 2 {p1x, p1y} {p0x, p0y})
					(vec-perp)
					(vec-add 2)
					(vec-store 2 {px, py})
					(f-call 'points 'push_back {out_points, p})
					(vec-load 2 {p1x, p1y} {p0x, p0y})
					(vec-add 2)
					(vec-store 2 {px, py})
					(f-call 'points 'push_back {out_points, p})
					(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
					(vec-add 2)
					(vec-store 2 {px, py})
					(f-call 'points 'push_back {out_points, p})
					(break)
				(default)
					;round cap
					(vec-load 2 {l2_rvx, l2_rvy})
					(vec-dup 2)
					(vec-perp)
					(vec-store 2 {p0x, p0y})
					(vec-load 1 {-1.0})
					(vec-scale 2)
					(vec-store 2 {px, py})
					(f-call 'points 'gen_clerp {out_points, stack, p1, p, p0, radius, eps})
					(f-call 'points 'gen_clerp {out_points, stack, p1, p0, l2_rv, radius, eps})
				(endswitch)
				(loop-while {iter != iter_begin && iter != iter_end})
					(vec-load 4 {p2, l2_v, l2_npv, l2_rv})
					(vec-store 4 {p1, l1_v, l1_npv, l1_rv})
					(assign {*iter, iter + step} {p2, iter})
					(vec-load 2 {p2x, p2y} {p1x, p1y})
					(vec-sub 2)
					(vec-dup 2)
					(vec-store 2 {l2_vx, l2_vy})
					(vec-perp)
					(vec-dup 2)
					(vec-store 2 {l2_pvx, l2_pvy})
					(vec-norm 2)
					(vec-dup 2)
					(vec-store 2 {l2_npvx, l2_npvy})
					(vec-load 1 {radius})
					(vec-scale 2)
					(vec-store 2 {l2_rvx, l2_rvy})

					;what kind of join
					(vec-load 2 {l1_npvx, l1_npvy} {l2_npvx, l2_npvy})
					(vec-perp)
					(vec-dot 2)
					(vec-store 1 {c})

					(switch)
					(case {c <= 0 || join_style == join_miter})
						;mitre join
						(vec-load 2 {p1x, p1y} {l1_rvx, l1_rvy})
						(vec-add 2)
						(vec-store 2 {p0x, p0y})
						(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
						(vec-add 2)
						(vec-store 2 {px, py})
						(f-call 'math 'vec_intersect {p0, l1_v, p, l2_v} {p})
						(f-call 'points 'push_back {out_points, p})
						(break)
					(case {join_style == join_bevel})
						;bevel join
						(vec-load 2 {p1x, p1y} {l1_rvx, l1_rvy})
						(vec-add 2)
						(vec-store 2 {px, py})
						(f-call 'points 'push_back {out_points, p})
						(vec-load 2 {p1x, p1y} {l2_rvx, l2_rvy})
						(vec-add 2)
						(vec-store 2 {px, py})
						(f-call 'points 'push_back {out_points, p})
						(break)
					(default)
						;rounded join
						(f-call 'points 'gen_clerp {out_points, stack, p1, l1_rv, l2_rv, radius, eps})
					(endswitch)
				(loop-end)
				(breakif {step < 0})
				(assign {-step} {step})
				(assign {iter + step} {iter})
			(loop-end)
			(f-call 'vector 'push_back {this, out_points})
			(assign {iter_begin_polylines + ptr_size} {iter_begin_polylines})
		(loop-end)
	(endif)

	(f-exit 'points 'stroke_polylines {this})
	(pop-scope)
	(return)

(def-func-end)
