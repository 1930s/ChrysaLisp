(import 'sys/func.inc)
(import 'class/points/points.inc)
(import 'sys/math/math.inc)

(gen-new 'points)
(gen-create 'points)
(gen-class 'points)

(def-func 'class/points/rem_co_polyline)
	;inputs
	;r0 = points object
	;r1 = dest points object, can be same
	;r2 = 16.16 tolerance
	;outputs
	;r0 = points object
	;trashes
	;all but r0, r4

	(ptr 'this 'that)
	(pptr 'iter_begin 'iter_end 'iter_that)
	(int 'eps)

	(push-scope)
	(f-entry 'points 'rem_co_polyline {this, that, eps})

	(f-call 'points 'get_begin {this} {_, iter_begin})
	(f-call 'points 'get_end {this} {_, iter_end})
	(f-call 'points 'get_begin {that} {_, iter_that})

	(vec-set 0)
	(vec-load 2 {iter_end, iter_begin})
	(vec-dup 2)
	(vec-dif 2)
	(vpif `(,(elem 0 (vec-pop 1)) > long_size))
		(vec-dup 1)
		(vec-load 2 {eps, iter_that})
		(vec-def (vec-top 5) e i j x k)
		(loop-start 'outer_loop)
			(vpif `(,i != ,k))
				(vec-load-long 1 i)
				(vec-store-long 1 k)
			(endif)
			(loop-start)
				(breakif `(,i == ,e) outer_loop)
				(vp-add-cr long_size i)
				(vec-load-int 2 j)
				(vec-load-int 2 i)
				(vec-manhattan 2)
			(loop-until `(,(elem 0 (vec-pop 1)) >= ,x))
			(vp-add-cr long_size k)
			(vp-add-cr long_size j)
		(loop-end)
		(vec-store 1 {iter_end})
		(f-call 'points 'set_length {that, iter_end - iter_that >> 3})
	(endif)

	(f-exit 'points 'rem_co_polyline {this})
	(pop-scope)
	(return)

(def-func-end)

(def-func 'class/points/rem_co_polygon)
	;inputs
	;r0 = points object
	;r1 = dest points object, can be same
	;r2 = 16.16 tolerance
	;outputs
	;r0 = points object
	;trashes
	;all but r0, r4

	(ptr 'this 'that)
	(pptr 'iter_begin 'iter_end)
	(int 'eps)

	(push-scope)
	(f-entry 'points 'rem_co_polygon {this, that, eps})

	(f-call 'points 'rem_co_polyline {this, that, eps})
	(f-call 'points 'get_begin {that} {_, iter_begin})
	(f-call 'points 'get_end {that} {_, iter_end})

	(vec-set 0)
	(vec-load 2 {iter_end, iter_begin})
	(vec-dup 2)
	(vec-dif 2)
	(vpif `(,(elem 0 (vec-pop 1)) > long_size))
		(vec-load 1 {eps})
		(vec-def (vec-top 3) e i x)
		(vec-load-int 2 i)
		(vec-load-int 2 e (neg long_size))
		(vec-manhattan 2)
		(vpif `(,(elem 0 (vec-pop 1)) < ,x))
			(d-call 'points 'pop_back {that})
		(endif)
	(endif)

	(f-exit 'points 'rem_co_polygon {this})
	(pop-scope)
	(return)

(def-func-end)

(def-func 'class/points/gen_clerp)
	;inputs
	;r0 = points object
	;r1 = stack array
	;r2 = 16.16 c.x
	;r3 = 16.16 c.y
	;r5 = 16.16 v1.x
	;r6 = 16.16 v1.y
	;r7 = 16.16 v2.x
	;r8 = 16.16 v2.y
	;r9 = 16.16 radius
	;outputs
	;r0 = points object
	;trashes
	;all but r0, r4

	(ptr 'this 'stack)
	(union
		'(ulong 'c 'v1 'v2 'v3 'bv)
		'(int 'cx 'cy 'v1x 'v1y 'v2x 'v2y 'v3x 'v3y 'bvx 'bvy))
	(int 'radius)
	(uint 'length)

	(push-scope)
	(f-entry 'points 'gen_clerp {this, stack, cx, cy, v1x, v1y, v2x, v2y, radius})

	(vpif {radius >= 0.5})
		(f-call 'array 'set_length {stack, 0})
		(f-call 'array 'push_back {stack, v1})
		(f-call 'array 'push_back {stack, v2})

		;output first point
		(vec-set 0)
		(vec-load 2 {cx, cy} {v1x, v1y})
		(vec-add 2)
		(vec-store 2 {bvx, bvy})
		(f-call 'array 'push_back {this, bv})

		(loop-start)
			(d-call 'array 'get_length {stack} {_, length})
			(breakifnot {length})
			(f-call 'array 'get_back {this} {_, v3})
			(d-call 'array 'pop_back {this})
			(f-call 'array 'get_back {this} {_, v1})
			(d-call 'array 'pop_back {this})

			;calculate the mid-point
			(vec-load 2 {v1x, v1y} {v3x, v3y})
			(vec-add 2)
			(vec-norm 2)
			(vec-load 1 {radius})
			(vec-scale 2)
			(vec-store 2 {bvx, bvy})

			;flatness test
			(vec-load 1 {v1x} {v3x})
			(vec-add 1)
			(vec-load 1 {bvx})
			(vec-dup 1)
			(vec-dif 3)
			(vec-load 1 {v1y} {v3y})
			(vec-add 1)
			(vec-load 1 {bvy})
			(vec-dup 1)
			(vec-dif 3)
			(vec-abs 2)
			(vec-sum 2)

			(vpif `(,(elem 0 (vec-pop 1)) <= 2.0))
				;output point
				(vec-load 2 {cx, cy} {bvx, bvy})
				(vec-add 2)
				(vec-store 2 {bvx, bvy})
				(f-call 'array 'push_back {this, bv})
			(else)
				;continue subdivision
				(f-call 'array 'push_back {stack, bv})
				(f-call 'array 'push_back {stack, v3})
				(f-call 'array 'push_back {stack, v1})
				(f-call 'array 'push_back {stack, bv})
			(endif)
		(loop-end)

		;output last point
		(vec-load 2 {cx, cy} {v2x, v2y})
		(vec-add 2)
		(vec-store 2 {bvx, bvy})
		(f-call 'array 'push_back {this, bv})
	(endif)

	(f-exit 'points 'gen_clerp {this})
	(pop-scope)
	(return)

(def-func-end)
