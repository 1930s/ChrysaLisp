(import 'sys/func.inc)
(import 'class/canvas/canvas.inc)

(def-func 'class/canvas/resize)
	;inputs
	;r0 = canvas object
	;r1 = source canvas object
	;outputs
	;r0 = canvas object
	;trashes
	;all but r0

	(ptr 'this 'source)
	(puint 'data 'dsrc)
	(uint 'x 'y 'x2 'y2)
	(uint 'x1a 'x1b 'x1c 'x1d 'y1a 'y1b 'y1c 'y1d)
	(uint 'a 'r 'g 'b 'q 'weight_x 'weight_y)
	(long 'fw 'fh)

	(push-scope)
	(f-entry 'canvas 'resize {this, source})

	(assign {(this->canvas_width + 1) * int_size} {x})
	(vpif {x > this->canvas_resize_buf_size})
		(vpif {this->canvas_resize_buf})
			(f-call 'sys_mem 'free {this->canvas_resize_buf})
		(endif)
		(f-call 'sys_mem 'alloc {x} {this->canvas_resize_buf, this->canvas_resize_buf_size})
	(endif)

	(assign {(source->canvas_width * 256) </ this->canvas_width} {fw})
	(assign {(source->canvas_height * 256) </ this->canvas_height} {fh})

	(assign {0} {x2})
	(loop-while {x2 < this->canvas_width})
		(assign {x2 *> fw} {(this->canvas_resize_buf)[x2 * int_size]})
		(assign {x2 + 1} {x2})
	(loop-end)
	(assign {source->canvas_width * 256} {(this->canvas_resize_buf)[x2 * int_size]})

	(assign {this->canvas_data} {data})
	(assign {0} {y2})
	(loop-while {y2 < this->canvas_height})
		(assign {y2 *> fh} {y1a})
		(assign {y1a >> 8} {y1c})
		(assign {((y2 + 1) *> fh) - 1} {y1b})
		(assign {y1b >> 8} {y1d})

		(assign {0} {x2})
		(loop-while {x2 < this->canvas_width})
			(assign {(this->canvas_resize_buf)[x2 * int_size]} {x1a})
			(assign {x1a >> 8} {x1c})
			(assign {(this->canvas_resize_buf)[(x2 + 1) * int_size] - 1} {x1b})
			(assign {x1b >> 8} {x1d})

			(assign {0, 0, 0, 0, 0} {a, r, g, b, q})

			(assign {y1c} {y})
			(loop-while {y <= y1d})
				(vp-def weight_y y1c y1d y y1a y1b)
				(assign {y1c, y1d} (list y1c y1d))
				(vp-cpy-cr 256 weight_y)
				(vpif `(,y1c != ,y1d))
					(assign {y, y1a, y1b} (list y y1a y1b))
					(vpif `(,y == ,y1c))
						(vp-and-cr 0xff y1a)
						(vp-sub-rr y1a weight_y)
					(elseif `(,y == ,y1d))
						(vp-and-cr 0xff y1b)
						(vp-add-cr 1 y1b)
						(vp-cpy-rr y1b weight_y)
					(endif)
				(endif)
				(assign (list weight_y) {weight_y})

				(assign {&(source->canvas_data)[(y * source->canvas_width + x1c) * int_size]} {dsrc})
				(assign {x1c} {x})
				(loop-while {x <= x1d})
					(vp-def weight_x x1c x1d x x1a x1b)
					(assign {x1c, x1d} (list x1c x1d))
					(vp-cpy-cr 256 weight_x)
					(vpif `(,x1c != ,x1d))
						(assign {x, x1a, x1b} (list x x1a x1b))
						(vpif `(,x == ,x1c))
							(vp-and-cr 0xff x1a)
							(vp-sub-rr x1a weight_x)
						(elseif `(,x == ,x1d))
							(vp-and-cr 0xff x1b)
							(vp-add-cr 1 x1b)
							(vp-cpy-rr x1b weight_x)
						(endif)
					(endif)
					(assign (list weight_x) {weight_x})

					;multiply pixel channels by the pixel weight and accumulate
					(vp-def r g b a q sr sg sb sa dsrc weight)
					(assign {r, g, b, a, q, dsrc, weight_x * weight_y} (list r g b a q dsrc weight))
					(vp-cpy-ir-ui dsrc 0 sa)
					(vp-add-cr int_size dsrc)
					(vp-cpy-rr sa sr)
					(vp-cpy-rr sa sg)
					(vp-cpy-rr sa sb)
					(vp-shr-cr 8 sg)
					(vp-shr-cr 16 sb)
					(vp-shr-cr 24 sa)
					(vp-and-cr 0xff sr)
					(vp-and-cr 0xff sg)
					(vp-and-cr 0xff sb)
					(vp-mul-rr weight sr)
					(vp-mul-rr weight sg)
					(vp-mul-rr weight sb)
					(vp-mul-rr weight sa)
					(vp-add-rr sr r)
					(vp-add-rr sg g)
					(vp-add-rr sb b)
					(vp-add-rr sa a)
					(vp-add-rr weight q)
					(assign (list dsrc r g b a q) {dsrc, r, g, b, a, q})

					(assign {x + 1} {x})
				(loop-end)
				(assign {y + 1} {y})
			(loop-end)

			;divide by the pixel weight and store
			(vp-def q r g b a data)
			(assign {(1 << 32) / q, r, g, b, a, data} (list q r g b a data))
			(vp-mul-rr q r)
			(vp-mul-rr q g)
			(vp-mul-rr q b)
			(vp-mul-rr q a)
			(vp-shr-cr 32 r)
			(vp-shr-cr 32 g)
			(vp-shr-cr 32 b)
			(vp-shr-cr 32 a)
			(vp-shl-cr 8 g)
			(vp-shl-cr 16 b)
			(vp-shl-cr 24 a)
			(vp-add-rr g r)
			(vp-add-rr b r)
			(vp-add-rr a r)
			(vp-cpy-ri-i r data 0)
			(vp-add-cr int_size data)
			(assign (list data) {data})

			(assign {x2 + 1} {x2})
		(loop-end)
		(assign {y2 + 1} {y2})
	(loop-end)

	(f-exit 'canvas 'resize {this})
	(pop-scope)
	(return)

(def-func-end)
